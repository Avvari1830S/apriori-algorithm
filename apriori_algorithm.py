# -*- coding: utf-8 -*-
"""apriori_algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eL0u3PHOHANsvWhtiVxWhOUF0AALwiif
"""

from PAMI.frequentPattern.basic import abstract as _ab

class Apriori(_ab._frequentPatterns):
    def __init__(self, iFile, oFile, sep=" "):
        super().__init__()
        self._minSup = float()
        self._startTime = float()
        self._endTime = float()
        self._finalPatterns = {}
        self._iFile = iFile
        self._oFile = oFile
        self._sep = sep
        self._memoryUSS = float()
        self._memoryRSS = float()
        self._Database = []

    def _creatingItemSets(self):
        self._Database = []
        if isinstance(self._iFile, _ab._pd.DataFrame):
            temp = []
            if self._iFile.empty:
                print("it's empty..")
            i = self._iFile.columns.values.tolist()
            if 'Transactions' in i:
                temp = self._iFile['Transactions'].tolist()

            for k in temp:
                self._Database.append(set(k))
        if isinstance(self._iFile, str):
            if _ab._validators.url(self._iFile):
                data = _ab._urlopen(self._iFile)
                for line in data:
                    line.strip()
                    line = line.decode("utf-8")
                    temp = [i.rstrip() for i in line.split(self._sep)]
                    temp = [x for x in temp if x]
                    self._Database.append(set(temp))
            else:
                try:
                    with open(self._iFile, 'r', encoding='utf-8') as f:
                        for line in f:
                            line.strip()
                            temp = [i.rstrip() for i in line.split(self._sep)]
                            temp = [x for x in temp if x]
                            self._Database.append(set(temp))
                except IOError:
                    print("File Not Found")
                    quit()

    def _convert(self, value):
        if type(value) is int:
            value = int(value)
        if type(value) is float:
            value = (len(self._Database) * value)
        if type(value) is str:
            if '.' in value:
                value = float(value)
                value = (len(self._Database) * value)
            else:
                value = int(value)
        return value

    def _candidateToFrequent(self, candidateList):
        candidateToFrequentList = {}
        for i in self._Database:
            dictionary = {
                frozenset(j): int(candidateToFrequentList.get(frozenset(j), 0)) + 1
                for j in candidateList if j.issubset(i)
            }
            candidateToFrequentList.update(dictionary)
        candidateToFrequentList = {
            key: value for key, value in candidateToFrequentList.items()
            if value >= self._minSup
        }
        return candidateToFrequentList

    @staticmethod
    def _frequentToCandidate(frequentList, length):
        frequentToCandidateList = []
        for i in frequentList:
            nextList = [
                i | j for j in frequentList
                if len(i | j) == length and (i | j) not in frequentToCandidateList
            ]
            frequentToCandidateList.extend(nextList)
        return sorted(frequentToCandidateList)

    def startMine(self):
        self._Database = []
        self._startTime = _ab._time.time()
        self._creatingItemSets()
        itemsList = sorted(list(set.union(*self._Database)))  # because Database is list
        items = [{i} for i in itemsList]
        itemsCount = len(items)
        self._minSup = self._convert(self._minSup)
        self._finalPatterns = {}
        for i in range(1, itemsCount):
            frequentSet = self._candidateToFrequent(items)
            for x, y in frequentSet.items():
                sample = "\t".join(x)
                self._finalPatterns[sample] = y
            items = self._frequentToCandidate(frequentSet, i + 1)
            if len(items) == 0:
                break  # finish apriori
        self._endTime = _ab._time.time()
        process = _ab._psutil.Process(_ab._os.getpid())
        self._memoryUSS = float()
        self._memoryRSS = float()
        self._memoryUSS = process.memory_full_info().uss
        self._memoryRSS = process.memory_info().rss
        print("Frequent patterns were generated successfully using the Apriori algorithm")

    def getMemoryUSS(self):
        return self._memoryUSS

    def getMemoryRSS(self):
        return self._memoryRSS

    def getRuntime(self):
        return self._endTime - self._startTime

    def getPatternsAsDataFrame(self):
        data = [[a.replace('\t', ' '), b] for a, b in self._finalPatterns.items()]
        dataFrame = _ab._pd.DataFrame(data, columns=['Patterns', 'Support'])
        return dataFrame

    def save(self):
        with open(self._oFile, 'w+') as writer:
            for x, y in self._finalPatterns.items():
                s1 = f"{x}\t:{y}"
                writer.write("%s\n" % s1)

    def getPatterns(self):
        return self._finalPatterns

    def printResults(self):
        print("Total number of Frequent Patterns:", len(self.getPatterns()))
        print("Total Memory in USS:", self.getMemoryUSS())
        print("Total Memory in RSS:", self.getMemoryRSS())
        print("Total Execution Time in ms:", self.getRuntime())


if __name__ == "__main__":
    if len(_ab._sys.argv) == 4 or len(_ab._sys.argv) == 5:
        iFile = _ab._sys.argv[1]
        oFile = _ab._sys.argv[2]
        minSup = _ab._sys.argv[3]
        if len(_ab._sys.argv) == 5:
            sep = _ab._sys.argv[4]
            _ap = Apriori(iFile, oFile, sep)
        else:
            _ap = Apriori(iFile, oFile)
        _ap._minSup = minSup
        _ap.startMine()
        _ap.save()
        _ap.printResults()
    else:
        print("Error! The number of input parameters does not match the total number of parameters provided")